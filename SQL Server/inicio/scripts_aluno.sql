/* ORGANIZANDO FISICAMENTE E LOGICAMENTE UM BANCO DE DADOS

1 - CRIAR UM BANCO COM ARQUIVOS PARA OS SETORES DE MARKETING E VENDAS
2 - CRIAR UM ARQUIVO GERAL (QUEM NÃO É MKT OU VENDAS)
3 - DEIXAR O MDF APENAS COM O DICIONÁRIO DE DADOS
4 - CRIAR 2 GRUPOS DE ARQUIVOS

*/

-- criamos as tabelas TB_MKT e TB_VENDAS pelo próprio SQL Server --

USE EMPRESA
GO

CREATE TABLE TB_EMPRESA(
	id INT,
	nome VARCHAR(50)
)
GO



-- INDO PARA OUTRO EXEMPLO --



-- CRIANDO A TABELA ALUNO --
/* conectando ao banco */
USE EMPRESA
GO

/* CRIACAO DE TABELAS */
CREATE TABLE ALUNO(
	IDALUNO INT PRIMARY KEY IDENTITY,
	NOME VARCHAR(30) NOT NULL,
	SEXO CHAR(1) NOT NULL,
	NASCIMENTO DATE NOT NULL,
	EMAIL VARCHAR(30) UNIQUE
)
GO

/* PODEMOS USAR:
IDENTITY(1,1) -> INICIAR EM 1 E INCREMENTAR DE 1 EM 1 
ACIMA ESTÁ DEFAULT */

/* NO SQL SERVER NÃO TEMOS ENUM, USAMOS O CHECK */

ALTER TABLE ALUNO
ADD CONSTRAINT CK_SEXO CHECK (SEXO IN('M','F'))
GO

/* DEFININDO RELACIONAMENTO 1 X 1 */

CREATE TABLE ENDERECO(
	IDENDERECO INT PRIMARY KEY IDENTITY(100,10),
	BAIRRO VARCHAR(30),
	UF CHAR(2) NOT NULL,
	CHECK (UF IN('RJ','SP','MG')),
	ID_ALUNO INT UNIQUE
)
GO

/* CRIANDO A FK */

ALTER TABLE ENDERECO 
ADD CONSTRAINT FK_ENDERECO_ALUNO
FOREIGN KEY(ID_ALUNO) REFERENCES ALUNO(IDALUNO)
GO

/* COMANDOS DE DESCRIÇÃO -> FUNCIONA COM PROCEDURES JÁ
CRIADAS E ARMAZENDAS NO SISTEMA */

-- DESC DETALHADO DA TABELA --
SP_COLUMNS ALUNO
GO

-- DESC COM MAIS DETALHES DA TABELA --
SP_HELP ALUNO
GO

/* INSERINDO DADOS */
INSERT INTO ALUNO VALUES('ANDRE','M','1981/12/09','ANDRE@IG.COM')
INSERT INTO ALUNO VALUES('ANA','F','1987/03/09','ANA@IG.COM')
INSERT INTO ALUNO VALUES('RUI','M','1965/07/09','RUI@IG.COM')
INSERT INTO ALUNO VALUES('JOAO','M','2002/11/09','JOAO@IG.COM')
GO

SELECT * FROM ALUNO
GO

/* INSERINDO ENDERECOS */
INSERT INTO ENDERECO VALUES('FLAMENGO','RJ',1)
INSERT INTO ENDERECO VALUES('MORUMBI','SP',2)
INSERT INTO ENDERECO VALUES('CENTRO','MG',3)
INSERT INTO ENDERECO VALUES('CENTRO','SP',4)
GO

/* CRIANDO A TABELA TELEFONES */
CREATE TABLE TELEFONE(
	IDTELEFONE INT PRIMARY KEY IDENTITY,
	TIPO CHAR(3) NOT NULL,
	NUMERO VARCHAR(10) NOT NULL,
	ID_ALUNO INT,
	CHECK (TIPO IN('RES','COM','CEL'))
)
GO

INSERT INTO TELEFONE VALUES('CEL','7899889',1)
INSERT INTO TELEFONE VALUES('RES','4325444',1)
INSERT INTO TELEFONE VALUES('COM','4354354',2)
INSERT INTO TELEFONE VALUES('CEL','2344556',2)
GO

/* PEGAR DATA ATUAL */
SELECT GETDATE()
GO

/* CLAUSULA AMBIGUA -> JOIN COM COLUNAS IGUAIS EM
MAIS DE UMA TABELA */
SELECT A.NOME, T.TIPO, T.NUMERO, E.BAIRRO, E.UF
FROM ALUNO A
INNER JOIN TELEFONE T
ON A.IDALUNO = T.ID_ALUNO
INNER JOIN ENDERECO E
ON A.IDALUNO = E.ID_ALUNO
GO
-- NÃO VAI APARECER QUEM NÃO TEM TELEFONE --

SELECT A.NOME, T.TIPO, T.NUMERO, E.BAIRRO, E.UF
FROM ALUNO A
LEFT JOIN TELEFONE T
ON A.IDALUNO = T.ID_ALUNO
INNER JOIN ENDERECO E
ON A.IDALUNO = E.ID_ALUNO
GO

-- PARA MUDAR O NOME DAS CELULAS NULAS --
SELECT
	A.NOME,
	ISNULL(T.TIPO,'SEM') AS 'TIPO',
	ISNULL(T.NUMERO,'NUMERO') AS 'TELEFONE',
	E.BAIRRO,
	E.UF
FROM ALUNO A
LEFT JOIN TELEFONE T
ON A.IDALUNO = T.ID_ALUNO
INNER JOIN ENDERECO E
ON A.IDALUNO = E.ID_ALUNO
GO

/* TRABALHANDO COM DATAS */
SELECT NOME, NASCIMENTO
FROM ALUNO
GO

/* DATEDIFF -> CALCULA DIFERENÇA ENTRE DUAS DATAS */
SELECT NOME, GETDATE() AS DIA_HORA FROM ALUNO
GO

SELECT NOME, DATEDIFF(YEAR,NASCIMENTO,GETDATE())
AS 'IDADE'
FROM ALUNO
GO

SELECT NOME, (DATEDIFF(DAY,NASCIMENTO,GETDATE())/365)
AS 'IDADE'
FROM ALUNO
GO

SELECT NOME, DATEDIFF(MONTH,NASCIMENTO,GETDATE())
AS 'MESES DE VIDA'
FROM ALUNO
GO

/* DATENAME - TRAZ O NOME DO MÊS */
SELECT NOME, DATENAME(MONTH,NASCIMENTO)
FROM ALUNO
GO

SELECT NOME, DATENAME(YEAR,NASCIMENTO)
FROM ALUNO
GO

/* DATEPART - RETORNA O MESMO QUE DATENAME, SÓ QUE UM INTEIRO */
SELECT NOME, DATEPART(MONTH,NASCIMENTO)
FROM ALUNO
GO

SELECT NOME, DATEPART(MONTH,NASCIMENTO), DATENAME(MONTH,NASCIMENTO)
FROM ALUNO
GO

/* DATEADD - RETORNA UMA DATA SOMANDO A OUTRA DATA */
SELECT DATEADD(DAY,365,GETDATE())
-- SOMANDO 365 DIAS DE HOJE --

SELECT DATEADD(YEAR,10,GETDATE())

/* CONVERSÃO DE DADOS */
SELECT 1 + '1'
GO -- RETORNA 2 --

SELECT '1' + '1'
GO --RETORNA 11 --

SELECT 'CURSO DE BANCO DE DADOS' + '1'
GO -- CURSO DE BANCO DE DADOS1 --

SELECT 'CURSO DE BANCO DE DADOS' + 1
GO -- ERRO --

/* A CONVERSÃO PADRÃO É SEMPRE DE STRING PARA NUMERICO */

/* FUNÇÕES DE CONVERSÃO DE DADOS */
SELECT CAST('1' AS INT) + CAST('1' AS INT)
GO

SELECT CAST('2' AS INT) + CAST('3' AS INT)
GO

/* CONVERSÃO E CONCATENAÇÃO */
/* https://msdn.microsoft.com/en-us/library/ms191530.aspx */

-- TRAZENDO DATA NO FORMATO BR --
SELECT NOME,
CAST(DAY(NASCIMENTO) AS VARCHAR) + '/' + 
CAST(MONTH(NASCIMENTO) AS VARCHAR) + '/' + 
CAST(YEAR(NASCIMENTO) AS VARCHAR) AS 'NASCIMENTO'
FROM ALUNO
GO

/* FUNÇÃO CHARINDEX - RETORNA UM INTEIRO BASEADO EM UMA PROCURA QUE
A GENTE FAZ EM UMA COLUNA 
OBS.: CONTAGEM DEFAULT INICIA EM 1
*/

SELECT NOME, CHARINDEX('A',NOME) AS 'INDICE'
FROM ALUNO
GO
-- VAI MOSTRAR A LOCALIZAÇÃO DA LETRA 'A' --

-- AGORA EU QUERO A PARTIR DA SEGUNDA POSIÇÃO --
SELECT NOME, CHARINDEX('A',NOME,2) AS 'INDICE'
FROM ALUNO
GO

/* BULK INSERT - importação de arquivos */
-- query para ajudar depois, não temos o arquivo --
CREATE TABLE LANCAMENTO_CONTABIL(
	CONTA INT,
	VALOR INT,
	DEBITO_CRED CHAR(1)
)
GO

BULK INSERT LANCAMENTO_CONTABIL
FROM 'C:\ARQUIVOS\CONTAS.TXT'
WITH
(
	FIRSTROW = 2, -- LINHA QUE COMEÇA --
	DATAFILETYPE = 'char', -- TIPO DE ARQUIVO --
	FIELDTERMINATOR = '\t', -- ONDE OS CAMPOS TERMINAM --
	ROWTERMINATOR = '\n' -- QUAL LINHA TERMINA --
)
GO
-- \t = tab --

SELECT * FROM LANCAMENTO_CONTABIL
GO

/* SALARIO ANTIGO, NOVO, DATA E NOME DO EMPREGO */
USE EMPRESA
GO

CREATE TABLE SALARIO_RANGE(
	MINSAL MONEY,
	MAXSAL MONEY
)
GO

INSERT INTO SALARIO_RANGE VALUES(2000.00,6000.00)
GO

CREATE TRIGGER TG_RANGE
ON DBO.EMPREGADO
FOR INSERT,UPDATE
AS
	DECLARE
		@MINSAL MONEY,
		@MAXSAL MONEY,
		@ATUALSAL MONEY
	SELECT @MINSAL = MINSAL,@MAXSAL = MAXSAL FROM SALARIO_RANGE

	SELECT @ATUALSAL = I.SALARIO
	FROM inserted I

	IF(@ATUALSAL < @MINSAL)
	BEGIN
		RAISERROR('SALARIO MENOR QUE O PISO',16,1)
		ROLLBACK TRANSACTION
	END

	IF(@ATUALSAL > @MAXSAL)
	BEGIN
		RAISERROR('SALARIO MAIOR QUE O TETO',16,1)
		ROLLBACK TRANSACTION
	END
GO

UPDATE EMPREGADO SET SALARIO = 9000
WHERE IDEMPREGADO = 1
GO

UPDATE EMPREGADO SET SALARIO = 500
WHERE IDEMPREGADO = 2
GO

